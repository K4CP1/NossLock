local GetService = setmetatable({}, {
	__index = function(self, key)
		return game:GetService(key)
	end
})

getgenv = getgenv
Drawing = Drawing

if getgenv().FaultyReturner then return getgenv().FaultyReturner end

local Area = game:GetService("Workspace")
local Players = game:GetService("Players")
local GetPlayers = Players.GetPlayers
local LocalPlayer = Players.LocalPlayer
local CharacterAdded = LocalPlayer.CharacterAdded
local CharacterAddedWait = CharacterAdded.Wait
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local CurrentCamera = Area.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local GetGuiInset = GuiService.GetGuiInset
local WorldToViewportPoint = CurrentCamera.WorldToViewportPoint
local EnumRaycastFilterTypeBlacklist = Enum.RaycastFilterType.Blacklist
local Raycast = Area.Raycast
local IsDescendantOf = Instance.new("Part").IsDescendantOf
local FindFirstChildWhichIsA = Instance.new("Part").FindFirstChildWhichIsA
local FindFirstChild = Instance.new("Part").FindFirstChild

getgenv().FaultyReturner = {
	SilentAimEnabled = true;
	ShowFOV = false;
	FOVSides = 64;
	VisibleCheck = true;
	TeamCheck = true;
	FOV = 250;
	HitChance = 100;
	Selected = LocalPlayer;
	SelectedPart = nil;
	TargetPart = {"Head", "HumanoidRootPart"};
	BlacklistedTeams = {
		{
			Team = LocalPlayer.Team;
			TeamColor = LocalPlayer.TeamColor;
		};
	};
	BlacklistedPlayers = {LocalPlayer};
	WhitelistedPUIDs = {79825365, 2887631667};
}

local FaultyReturner = getgenv().FaultyReturner
local circle = Drawing.new("Circle")
circle.Transparency = 1
circle.Thickness = 1
circle.Color = Color3.new(0, 0, 0)
circle.Filled = false
circle.Visible = false
function FaultyReturner.MoveCircle()
	if (circle) then
		circle.Visible = FaultyReturner.ShowFOV
		circle.Radius = (FaultyReturner.FOV * 3)
		circle.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GuiService).Y)
		circle.NumSides = FaultyReturner.FOVSides
		return circle
	end
end
local DoChance = function(percentage)
	percentage = math.floor(percentage)
	local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
	return chance <= percentage / 100
end
function FaultyReturner.isPartVisible(Part, PartDescendant)
	local Character = LocalPlayer.Character or CharacterAddedWait(CharacterAdded)
	local Origin = CurrentCamera.CFrame.Position
	local _, OnScreen = WorldToViewportPoint(CurrentCamera, Part.Position)
	if (OnScreen) then
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = EnumRaycastFilterTypeBlacklist
		raycastParams.FilterDescendantsInstances = {Character, CurrentCamera}
		local Result = Raycast(Area, Origin, Part.Position - Origin, raycastParams)
		if (Result) then
			local PartHit = Result.Instance
			local Visible = (not PartHit or IsDescendantOf(PartHit, PartDescendant))
			return Visible
		end
	end
	return false
end
function FaultyReturner.checkTeam(targetPlayerA, targetPlayerB)
	if (targetPlayerA.Team ~= targetPlayerB.Team) then
		for i = 1, #FaultyReturner.BlacklistedTeams do
			local v = FaultyReturner.BlacklistedTeams

			if (targetPlayerA.Team ~= v.Team and targetPlayerA.TeamColor ~= v.TeamColor) then
				return true
			end
		end
	end
	return false
end
function FaultyReturner.checkPlayer(targetPlayer)
	for i = 1, #FaultyReturner.BlacklistedPlayers do
		local v = FaultyReturner.BlacklistedPlayers[i]
		if (v ~= targetPlayer) then
			return true
		end
	end
	return false
end
function FaultyReturner.checkWhitelisted(targetPlayer)
	for i = 1, #FaultyReturner.WhitelistedPUIDs do
		local v = FaultyReturner.WhitelistedPUIDs[i]
		if (targetPlayer.UserId == v) then
			return true
		end
	end
	return false
end
function FaultyReturner.getCharacter(Player)
	return Player.Character
end
function FaultyReturner.checkHealth(Player)
	local Character = FaultyReturner.getCharacter(Player)
	local Humanoid = FindFirstChildWhichIsA(Character, "Humanoid")
	local Health = (Humanoid and Humanoid.Health or 0)
	return Health > 0
end
function FaultyReturner.getClosestTargetPartToCursor(Character)
	local TargetParts = FaultyReturner.TargetPart
	local ClosestPart = nil
	local ClosestPartPosition = nil
	local ClosestPartOnScreen = false
	local ClosestPartMagnitudeFromMouse = nil
	local ShortestDistance = 1/0
	local function checkTargetPart(TargetPartName)
		local TargetPart = FindFirstChild(Character, TargetPartName)
		if (TargetPart) then
			local PartPos, onScreen = WorldToViewportPoint(CurrentCamera, TargetPart.Position)
			local Magnitude = (Vector2.new(PartPos.X, PartPos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
			if (Magnitude < ShortestDistance) then
				ClosestPart = TargetPart
				ClosestPartPosition = PartPos
				ClosestPartOnScreen = onScreen
				ClosestPartMagnitudeFromMouse = Magnitude
				ShortestDistance = Magnitude
			end
		end
	end
	if (typeof(TargetParts) == "string") then
		checkTargetPart(TargetParts)
	end
	if (typeof(TargetParts) == "table") then
		for i = 1, #TargetParts do
			local TargetPartName = TargetParts[i]
			checkTargetPart(TargetPartName)
		end
	end
	return ClosestPart, ClosestPartPosition, ClosestPartOnScreen, ClosestPartMagnitudeFromMouse
end
function FaultyReturner.getClosestPlayerToCursor()
	local TargetPart = nil
	local ClosestPlayer = nil
	local Chance = DoChance(FaultyReturner.HitChance)
	local ShortestDistance = 1/0
	if (not Chance) then
		FaultyReturner.Selected = LocalPlayer
		FaultyReturner.SelectedPart = nil

		return LocalPlayer
	end
	local AllPlayers = GetPlayers(Players)
	for i = 1, #AllPlayers do
		local Player = AllPlayers[i]
		local Character = FaultyReturner.getCharacter(Player)
		if (not FaultyReturner.checkWhitelisted(Player) and FaultyReturner.checkPlayer(Player) and Character) then
			local TargetPartTemp, PartPos, onScreen, Magnitude = FaultyReturner.getClosestTargetPartToCursor(Character)
			if (TargetPartTemp and FaultyReturner.checkHealth(Player)) then
				if (FaultyReturner.TeamCheck and not FaultyReturner.checkTeam(Player, LocalPlayer)) then continue end
				if (circle.Radius > Magnitude and Magnitude < ShortestDistance) then
					if (FaultyReturner.VisibleCheck and not FaultyReturner.isPartVisible(TargetPartTemp, Character)) then continue end
					ClosestPlayer = Player
					ShortestDistance = Magnitude
					TargetPart = TargetPartTemp
				end
			end
		end
	end
	FaultyReturner.Selected = ClosestPlayer
	FaultyReturner.SelectedPart = TargetPart
end
Heartbeat:Connect(function()
	FaultyReturner.MoveCircle()
	FaultyReturner.getClosestPlayerToCursor()
end) 
return FaultyReturner
